package org.opensha.gmm;

import static java.lang.Math.log;
import static java.lang.Math.min;
import static org.opensha.gmm.FaultStyle.REVERSE;

import java.util.Map;

/**
 * Implementation of the Idriss (2014) next generation ground motion model for
 * active crustal regions developed as part of <a
 * href="http://peer.berkeley.edu/ngawest2">NGA West II</a>.
 * 
 * <p><b>Note:</b> Direct instantiation of {@code GroundMotionModel}s is
 * prohibited. Use {@link Gmm#instance(Imt)} to retrieve an instance for a
 * desired {@link Imt}.</p>
 * 
 * <p><b>Implementation notes:</b> Idriss (2014) recommends a cap of Vs=1200m/s
 * (implemented) and a distance limit of 150km (not implemented).</p>
 * 
 * <p><b>Implementation notes:</b> 0.01s SA values used for PGA.</p>
 * 
 * <p><b>Reference:</b> Idriss, I.M., 2014, An NGA-West2 empirical model for
 * estimating the horizontal spectral values generated by shallow crustal
 * earthquakes, Earthquake Spectra, v. 30, n. 3, p. 1155-1177.
 * 
 * <p><b>doi:</b> <a href="http://dx.doi.org/10.1193/070613EQS195M">
 * http://dx.doi.org/10.1193/070613EQS195M</a></p>
 * 
 * <p><b>Component:</b> RotD50 (average horizontal)</p>
 * 
 * @author Peter Powers
 * @see Gmm#IDRISS_14
 */
public final class Idriss_2014 implements GroundMotionModel {

	static final String NAME = "Idriss (2014)";

	static final CoefficientsNew COEFFS = new CoefficientsNew("Idriss14.csv");

	private static final class Coeffs {

		double a1_lo, a2_lo, a1_hi, a2_hi, a3, b1_lo, b2_lo, b1_hi, b2_hi, ξ, γ, φ;

		Coeffs(Map<String, Double> coeffs) {
			a1_lo = coeffs.get("a1_lo");
			a2_lo = coeffs.get("a2_lo");
			a1_hi = coeffs.get("a1_hi");
			a2_hi = coeffs.get("a2_hi");
			a3 = coeffs.get("a3");
			b1_lo = coeffs.get("b1_lo");
			b2_lo = coeffs.get("b2_lo");
			b1_hi = coeffs.get("b1_hi");
			b2_hi = coeffs.get("b2_hi");
			ξ = coeffs.get("xi");
			γ = coeffs.get("gamma");
			φ = coeffs.get("phi");
		}
	}

	private final Coeffs coeffs;
	private final Imt imt;

	Idriss_2014(Imt imt) {
		this.imt = imt;
		coeffs = new Coeffs(COEFFS.get(imt));
	}

	@Override public final ScalarGroundMotion calc(GmmInput in) {
		return calc(coeffs, imt, in);
	}

	private static final ScalarGroundMotion calc(final Coeffs c, final Imt imt, final GmmInput in) {

		double mean = calcMean(c, in);
		double stdDev = calcStdDev(c, imt, in.Mw);

		return DefaultScalarGroundMotion.create(mean, stdDev);
	}

	// Mean ground motion model - cap of Vs = 1200 m/s
	private static final double calcMean(final Coeffs c, final GmmInput in) {

		double Mw = in.Mw;
		double rRup = in.rRup;

		FaultStyle style = GmmUtils.rakeToFaultStyle_NSHMP(in.rake);

		double a1 = c.a1_lo, a2 = c.a2_lo;
		double b1 = c.b1_lo, b2 = c.b2_lo;
		if (Mw > 6.75) {
			a1 = c.a1_hi;
			a2 = c.a2_hi;
			b1 = c.b1_hi;
			b2 = c.b2_hi;
		}

		return a1 + a2 * Mw + c.a3 * (8.5 - Mw) * (8.5 - Mw) - (b1 + b2 * Mw) * log(rRup + 10.0) +
			c.ξ * log(min(in.vs30, 1200.0)) + c.γ * rRup + (style == REVERSE ? c.φ : 0.0);
	}

	// Aleatory uncertainty model
	private static final double calcStdDev(final Coeffs c, final Imt imt, final double Mw) {
		double s1 = 0.035;
		Double T = imt.period();
		s1 *= (T == null || T <= 0.05) ? log(0.05) : (T < 3.0) ? log(T) : log(3d);
		double s2 = 0.06;
		s2 *= (Mw <= 5.0) ? 5.0 : (Mw < 7.5) ? Mw : 7.5;
		return 1.18 + s1 - s2;
	}

}
